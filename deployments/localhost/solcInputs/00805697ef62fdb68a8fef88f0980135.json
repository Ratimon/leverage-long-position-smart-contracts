{
  "language": "Solidity",
  "sources": {
    "src/CompoundBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.13;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IComptroller} from \"./interfaces/IComptroller.sol\";\nimport {ICEther} from \"./interfaces/ICEther.sol\";\nimport {ICToken} from \"./interfaces/ICToken.sol\";\n\ncontract CompoundBase {\n    error Compound_cTokenMint();\n    error Compound_cTokenRedeem();\n    error Compound_cTokenBorrow();\n    error Compound_cTokenRepayborrow();\n\n    error Compound_comptrollerEntermarket();\n    error Compound_comptrollerAccountLiquidityError();\n    error Compound_comptrollerAccountLiquidityshortfall();\n    error Compound_comptrollerAccountLiquidityZero();\n\n    IComptroller public immutable comptroller;\n    ICEther public immutable cEther;\n\n    constructor(address _comptroller, address _cEther) {\n        require(\n            _comptroller != address(0) && _cEther != address(0),\n            \"account cannot be the zero address\"\n        );\n        comptroller = IComptroller(_comptroller);\n        cEther = ICEther(_cEther);\n    }\n\n    function supply(address _cTokenAddress, uint256 _underlyingAmount)\n        internal\n    {\n        if (_cTokenAddress == address(cEther)) {\n            _supplyETH(_cTokenAddress, _underlyingAmount);\n        } else {\n            _supplyERC20(_cTokenAddress, _underlyingAmount);\n        }\n    }\n\n    function _supplyETH(address _cTokenAddress, uint256 _underlyingAmount)\n        private\n    {\n        require(msg.value > 0, \"must send ether along\");\n        ICEther cToken = ICEther(_cTokenAddress);\n        cToken.mint{value: _underlyingAmount}();\n    }\n\n    function _supplyERC20(address _cTokenAddress, uint256 _underlyingAmount)\n        private\n    {\n        require(msg.value == 0, \"cant send ether along\");\n        ICToken cToken = ICToken(_cTokenAddress);\n        address underlyingAddress = cToken.underlying();\n        IERC20(underlyingAddress).approve(_cTokenAddress, _underlyingAmount);\n        uint256 result = cToken.mint(_underlyingAmount);\n\n        if (result != 0) revert Compound_cTokenMint();\n    }\n\n    function redeemUnderliying(\n        address _cTokenAddress,\n        uint256 _underlyingAmount\n    ) internal {\n        ICToken cToken = ICToken(_cTokenAddress);\n\n        uint256 result = cToken.redeemUnderlying(_underlyingAmount);\n\n        if (result != 0) revert Compound_cTokenRedeem();\n    }\n\n    function borrow(address _cTokenAddress, uint256 _underlyingAmount)\n        internal\n    {\n        ICToken cToken = ICToken(_cTokenAddress);\n        uint256 result = cToken.borrow(_underlyingAmount);\n\n        if (result != 0) revert Compound_cTokenBorrow();\n    }\n\n    function repayBorrow(address _cTokenAddress, uint256 _underlyingAmount)\n        internal\n    {\n        if (_cTokenAddress == address(cEther)) {\n            _repayBorrowETH(_cTokenAddress, _underlyingAmount);\n        } else {\n            _repayBorrowERC20(_cTokenAddress, _underlyingAmount);\n        }\n    }\n\n    function _repayBorrowETH(address _cTokenAddress, uint256 _underlyingAmount)\n        internal\n    {\n        ICEther cToken = ICEther(_cTokenAddress);\n        cToken.repayBorrow{value: _underlyingAmount}();\n    }\n\n    function _repayBorrowERC20(\n        address _cTokenAddress,\n        uint256 _underlyingAmount\n    ) internal {\n        ICToken cToken = ICToken(_cTokenAddress);\n        uint256 result = cToken.repayBorrow(_underlyingAmount);\n\n        if (result != 0) revert Compound_cTokenRepayborrow();\n    }\n\n    function enterMarket(address cTokenAddress) internal {\n        address[] memory markets = new address[](1);\n        markets[0] = cTokenAddress;\n        uint256[] memory results = comptroller.enterMarkets(markets);\n\n        if (results[0] != 0) revert Compound_comptrollerEntermarket();\n    }\n\n    function claimComp() internal {\n        comptroller.claimComp(address(this));\n    }\n\n    function getCompAddress() internal view returns (address) {\n        return comptroller.getCompAddress();\n    }\n\n    function getAccountLiquidity() internal view returns (uint256) {\n        (uint256 error, uint256 liquidity, uint256 shortfall) = comptroller\n            .getAccountLiquidity(address(this));\n\n        if (error != 0) revert Compound_comptrollerAccountLiquidityError();\n        if (shortfall != 0)\n            revert Compound_comptrollerAccountLiquidityshortfall();\n\n        if (liquidity == 0) revert Compound_comptrollerAccountLiquidityZero();\n\n        return liquidity;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "src/interfaces/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.13;\n\ninterface IComptroller {\n    function enterMarkets(address[] calldata cTokens)\n        external\n        returns (uint256[] memory);\n\n    function claimComp(address holder) external;\n\n    function getAccountLiquidity(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function getCompAddress() external view returns (address);\n\n    function redeemAllowed(\n        address cToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) external returns (uint256);\n}\n"
    },
    "src/interfaces/ICEther.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.13;\n\ninterface ICEther {\n    function mint() external payable;\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function repayBorrow() external payable;\n\n    function totalBorrows() external returns (uint256);\n\n    function borrowBalanceCurrent(address account) external returns (uint256);\n\n    function borrowBalanceStored(address account) external returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function balanceOfUnderlying(address account) external returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function isCToken() external view returns (bool);\n}\n"
    },
    "src/interfaces/ICToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.13;\n\ninterface ICToken {\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n    function borrowBalanceCurrent(address account) external returns (uint256);\n\n    function borrowBalanceStored(address account)\n        external\n        view\n        returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function underlying() external view returns (address);\n\n    function isCToken() external view returns (bool);\n}\n"
    },
    "src/LongPosition.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.13;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ICEther, ICToken, CompoundBase} from \"./CompoundBase.sol\";\nimport {ILongPosition, Decimal} from \"./ILongPosition.sol\";\n\nimport {UniswapBase} from \"./UniswapBase.sol\";\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport {IOracle, IOracleRef} from \"./refs/OracleRef.sol\";\n\ncontract LongPosition is ILongPosition, Pausable, CompoundBase, UniswapBase {\n    using Address for address;\n    using Decimal for Decimal.D256;\n    using SafeERC20 for IERC20;\n\n    uint256 public immutable BASIS_POINTS_GRANULARITY = 10_000;\n    uint256 public immutable leverage = 3_000;\n\n    IOracleRef public borrowOracle;\n    IOracleRef public supplyOracle;\n\n    ICEther public cTokenToSupply;\n    ICToken public cTokenToBorrow;\n\n    struct Position {\n        uint256 id;\n        address owner;\n        bool isActive;\n        uint256 depositAmount;\n        uint256 borrowAmount;\n        uint256 leverageAmount;\n    }\n\n    mapping(uint256 => Position) positions;\n    uint256 currentPosionId = 1;\n\n    constructor(\n        address _router,\n        address _comptroller,\n        address _cEther,\n        address _borrowOracle,\n        address _supplyOracle,\n        address _cTokenToSupply,\n        address _cTokenToBorrow\n    ) CompoundBase(_comptroller, _cEther) UniswapBase(_router) {\n        require(\n            _borrowOracle != address(0) &&\n                _supplyOracle != address(0) &&\n                _cTokenToSupply != address(0) &&\n                _cTokenToBorrow != address(0),\n            \"account cannot be the zero address\"\n        );\n        borrowOracle = IOracleRef(_borrowOracle);\n        supplyOracle = IOracleRef(_supplyOracle);\n        cTokenToSupply = ICEther(_cTokenToSupply);\n        require(cTokenToSupply.isCToken(), \"Not a cToken\");\n        cTokenToBorrow = ICToken(_cTokenToBorrow);\n        require(cTokenToBorrow.isCToken(), \"Not a cToken\");\n        IERC20(cTokenToBorrow.underlying()).approve(\n            address(router),\n            type(uint256).max\n        );\n        IERC20(cTokenToBorrow.underlying()).approve(\n            address(cTokenToBorrow),\n            type(uint256).max\n        );\n    }\n\n    receive() external payable {}\n\n    function openPosition() external payable whenNotPaused returns (uint256) {\n        require(msg.value > 0, \"must send arbitary amount of ether along with\");\n        Position storage currentPosition = positions[currentPosionId];\n        require(\n            currentPosition.isActive == false,\n            \"position is already active\"\n        );\n        currentPosition.isActive = true;\n        currentPosition.id = currentPosionId;\n        currentPosition.owner = msg.sender;\n\n        uint256 depositAmount = msg.value;\n        currentPosition.depositAmount = depositAmount;\n        _depositCollateral(depositAmount);\n\n        emit Deposit(msg.sender, msg.value);\n\n        uint256 borrowAmount = _caculateBorrowAmount(depositAmount);\n        currentPosition.borrowAmount = borrowAmount;\n        _targetAndBorrow(borrowAmount);\n\n        uint256 leverageAmount = buyETH(\n            borrowAmount,\n            cTokenToBorrow.underlying()\n        );\n        currentPosition.leverageAmount = leverageAmount;\n\n        emit PositionUpdate(\n            currentPosionId,\n            msg.sender,\n            false,\n            true,\n            0,\n            msg.value,\n            0,\n            borrowAmount,\n            0,\n            leverageAmount\n        );\n\n        return leverageAmount;\n    }\n\n    function closePosition() external whenNotPaused {\n        Position memory previousPosition = positions[currentPosionId];\n        Position storage currentPosition = positions[currentPosionId];\n\n        require(\n            currentPosition.isActive == true,\n            \"current position must be active\"\n        );\n        currentPosition.isActive = false;\n\n        require(\n            currentPosition.owner == msg.sender,\n            \"only position owner can withdraw\"\n        );\n\n        currentPosition.depositAmount = 0;\n        sellETH(currentPosition.leverageAmount, cTokenToBorrow.underlying());\n\n        currentPosition.borrowAmount = 0;\n        currentPosition.leverageAmount = 0;\n        _closeLoan();\n        emit PositionUpdate(\n            currentPosionId,\n            msg.sender,\n            true,\n            false,\n            previousPosition.depositAmount,\n            0,\n            previousPosition.borrowAmount,\n            0,\n            previousPosition.leverageAmount,\n            0\n        );\n\n        _withdrawCapitalAndProfit();\n\n        currentPosionId++;\n    }\n\n    function _depositCollateral(uint256 _underlyingAmount) private {\n        supply(address(cTokenToSupply), _underlyingAmount);\n    }\n\n    function _caculateBorrowAmount(uint256 _depositAmount)\n        private\n        returns (uint256 borrowAmount)\n    {\n        supplyOracle.updateOracle();\n        uint256 usdValueIncollateral = supplyOracle\n            .readOracle()\n            .mul(_depositAmount)\n            .asUint256();\n        Decimal.D256 memory maxLeverage = getMaxLeverage();\n        borrowAmount = maxLeverage.mul(usdValueIncollateral).asUint256();\n    }\n\n    function _targetAndBorrow(uint256 _underlyingAmount) private {\n        enterMarket(address(cTokenToSupply));\n        borrowOracle.updateOracle();\n        uint256 maxBorrowAmount = getMaxBorrowAmount();\n\n        if (_underlyingAmount > maxBorrowAmount)\n            _underlyingAmount = maxBorrowAmount;\n        borrow(address(cTokenToBorrow), _underlyingAmount);\n    }\n\n    function _closeLoan() private {\n        // repay borrow\n        uint256 amountToRepay = cTokenToBorrow.borrowBalanceCurrent(\n            address(this)\n        );\n        repayBorrow(address(cTokenToBorrow), amountToRepay);\n        // redeem\n        uint256 amountToSettle = cTokenToSupply.balanceOfUnderlying(\n            address(this)\n        );\n        redeemUnderliying(address(cTokenToSupply), amountToSettle);\n    }\n\n    function _withdrawCapitalAndProfit() private {\n        address borrowToken = cTokenToBorrow.underlying();\n        uint256 profitAmount = IERC20(borrowToken).balanceOf(address(this));\n        IERC20(borrowToken).safeTransfer(msg.sender, profitAmount);\n        emit WithdrawERC20(msg.sender, borrowToken, msg.sender, profitAmount);\n\n        Address.sendValue(payable(msg.sender), address(this).balance);\n        emit WithdrawETH(msg.sender, msg.sender, address(this).balance);\n\n        claimComp();\n        address comp = getCompAddress();\n        uint256 bonusAmount = IERC20(comp).balanceOf(address(this));\n        IERC20(comp).safeTransfer(msg.sender, bonusAmount);\n        emit WithdrawERC20(msg.sender, comp, msg.sender, bonusAmount);\n    }\n\n    function getMaxBorrowAmount() public view returns (uint256) {\n        uint256 liquidity = getAccountLiquidity();\n        // (DAI per USD)\n        Decimal.D256 memory inverted = borrowOracle.invert(\n            borrowOracle.readOracle()\n        );\n        // (DAI per USD) x (USD per ETH)\n        uint256 maxAmountInBorrowedToken = inverted.mul(liquidity).asUint256();\n        return maxAmountInBorrowedToken;\n    }\n\n    function getMaxLeverage() public pure returns (Decimal.D256 memory) {\n        uint256 granularity = BASIS_POINTS_GRANULARITY;\n        return Decimal.ratio(leverage, granularity);\n    }\n\n    function isCurrentPositionActive() external view returns (bool) {\n        Position memory currentPosition = positions[currentPosionId];\n        return currentPosition.isActive;\n    }\n\n    function getCurrentPositionOwner() external view returns (address) {\n        Position memory currentPosition = positions[currentPosionId];\n        return currentPosition.owner;\n    }\n\n    function getCurrentDepositAmount() external view returns (uint256) {\n        Position memory currentPosition = positions[currentPosionId];\n        return currentPosition.depositAmount;\n    }\n\n    function getCurrentBorrowAmount() external view returns (uint256) {\n        Position memory currentPosition = positions[currentPosionId];\n        return currentPosition.borrowAmount;\n    }\n\n    function getCurrentLeverageAmount() external view returns (uint256) {\n        Position memory currentPosition = positions[currentPosionId];\n        return currentPosition.leverageAmount;\n    }\n\n    function getTotalExposure() external view returns (uint256) {\n        Position memory currentPosition = positions[currentPosionId];\n        return (currentPosition.depositAmount + currentPosition.leverageAmount);\n    }\n\n    function getExpectedUniSwapOutput() public view returns (uint256) {\n        Position memory currentPosition = positions[currentPosionId];\n        return\n            getAmountsOut(\n                currentPosition.leverageAmount,\n                router.WETH(),\n                cTokenToBorrow.underlying()\n            );\n    }\n\n    function getCurrentETHPrice()\n        external\n        view\n        returns (uint256 currentETHPrice)\n    {\n        currentETHPrice = supplyOracle.readOracle().asUint256();\n    }\n\n    function getExpectedProfitInUsd() external view returns (uint256) {\n        uint256 amountToRepay = cTokenToBorrow.borrowBalanceStored(\n            address(this)\n        );\n        uint256 usdValueInCost = borrowOracle\n            .readOracle()\n            .mul(amountToRepay)\n            .asUint256();\n\n        uint256 amountToReceieve = getExpectedUniSwapOutput();\n        uint256 usdValueInSale = borrowOracle\n            .readOracle()\n            .mul(amountToReceieve)\n            .asUint256();\n\n        if (usdValueInSale > usdValueInCost) {\n            return usdValueInSale - usdValueInCost;\n        } else {\n            return usdValueInCost - usdValueInSale;\n        }\n    }\n}\n"
    },
    "src/ILongPosition.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.13;\n\nimport {Decimal} from \"./refs/OracleRef.sol\";\n\n/// @title LongPosition interface\ninterface ILongPosition {\n    // ----------- Events -----------\n\n    event PositionUpdate(\n        uint256 indexed id,\n        address indexed owner,\n        bool oldIsActive,\n        bool newIsActive,\n        uint256 oldDepositAmount,\n        uint256 newDepositAmount,\n        uint256 oldBorrowAmount,\n        uint256 newBorrowAmount,\n        uint256 oldLeverageAmount,\n        uint256 newLeverageAmount\n    );\n\n    event Deposit(address indexed _from, uint256 _amount);\n\n    event WithdrawERC20(\n        address indexed _caller,\n        address indexed _token,\n        address indexed _to,\n        uint256 _amount\n    );\n\n    event WithdrawETH(\n        address indexed _caller,\n        address indexed _to,\n        uint256 _amount\n    );\n\n    // ----------- State changing API -----------\n\n    function openPosition() external payable returns (uint256);\n\n    function closePosition() external;\n\n    // ----------- Getters -----------\n\n    function getMaxBorrowAmount() external view returns (uint256);\n\n    function getMaxLeverage() external pure returns (Decimal.D256 memory);\n\n    function isCurrentPositionActive() external view returns (bool);\n\n    function getCurrentPositionOwner() external view returns (address);\n\n    function getCurrentDepositAmount() external view returns (uint256);\n\n    function getCurrentBorrowAmount() external view returns (uint256);\n\n    function getCurrentLeverageAmount() external view returns (uint256);\n\n    function getTotalExposure() external view returns (uint256);\n\n    function getExpectedUniSwapOutput() external view returns (uint256);\n\n    function getCurrentETHPrice()\n        external\n        view\n        returns (uint256 currentETHPrice);\n\n    function getExpectedProfitInUsd() external view returns (uint256);\n}\n"
    },
    "src/UniswapBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.13;\n\nimport {IUniswapV2Router} from \"./interfaces/IUniswapV2Router.sol\";\nimport {UniswapV2Library} from \"./external/UniswapV2Library.sol\";\n\ncontract UniswapBase {\n    IUniswapV2Router immutable router;\n\n    constructor(address _router) {\n        require(_router != address(0), \"account cannot be the zero address\");\n        router = IUniswapV2Router(_router);\n    }\n\n    function buyETH(uint256 amountIn, address from)\n        internal\n        returns (uint256 amountETHOut)\n    {\n        address[] memory path = new address[](2);\n        path[0] = from;\n        path[1] = router.WETH();\n\n        amountETHOut = router.swapExactTokensForETH(\n            amountIn,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        )[1];\n    }\n\n    function sellETH(uint256 amountIn, address to)\n        internal\n        returns (uint256 amountERC20Out)\n    {\n        address[] memory path = new address[](2);\n        path[0] = router.WETH();\n        path[1] = to;\n\n        amountERC20Out = router.swapExactETHForTokens{value: amountIn}(\n            0,\n            path,\n            address(this),\n            block.timestamp\n        )[1];\n    }\n\n    function getAmountsOut(\n        uint256 amountIn,\n        address from,\n        address to\n    ) internal view returns (uint256) {\n        address factory = router.factory();\n\n        address[] memory path = new address[](2);\n        path[0] = from;\n        path[1] = to;\n\n        uint256[] memory amounts = UniswapV2Library.getAmountsOut(\n            factory,\n            amountIn,\n            path\n        );\n        return amounts[1];\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "src/refs/OracleRef.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity =0.8.13;\n\nimport {IOracleRef, IOracle, Decimal} from \"./IOracleRef.sol\";\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/// @title Reference to an Oracle\n/// @notice defines some utilities around interacting with the referenced oracle\nabstract contract OracleRef is IOracleRef, Ownable {\n    using Decimal for Decimal.D256;\n    using SafeCast for int256;\n\n    /// @notice the oracle reference by the contract\n    IOracle public override oracle;\n\n    /// @notice the backup oracle reference by the contract\n    IOracle public override backupOracle;\n\n    /// @notice number of decimals to scale oracle price by, i.e. multiplying by 10^(decimalsNormalizer)\n    int256 public override decimalsNormalizer;\n\n    bool public override doInvert;\n\n    /// @notice OracleRef constructor\n    /// @param _oracle oracle to reference\n    /// @param _backupOracle backup oracle to reference\n    /// @param _decimalsNormalizer number of decimals to normalize the oracle feed if necessary\n    /// @param _doInvert invert the oracle price if this flag is on\n    constructor(\n        address _oracle,\n        address _backupOracle,\n        int256 _decimalsNormalizer,\n        bool _doInvert\n    ) {\n        _setOracle(_oracle);\n        if (_backupOracle != address(0) && _backupOracle != _oracle) {\n            _setBackupOracle(_backupOracle);\n        }\n        _setDoInvert(_doInvert);\n        _setDecimalsNormalizer(_decimalsNormalizer);\n    }\n\n    /// @notice sets the referenced oracle\n    /// @param newOracle the new oracle to reference\n    function setOracle(address newOracle) external override onlyOwner {\n        _setOracle(newOracle);\n    }\n\n    /// @notice sets the flag for whether to invert or not\n    /// @param newDoInvert the new flag for whether to invert\n    function setDoInvert(bool newDoInvert) external override onlyOwner {\n        _setDoInvert(newDoInvert);\n    }\n\n    /// @notice sets the new decimalsNormalizer\n    /// @param newDecimalsNormalizer the new decimalsNormalizer\n    function setDecimalsNormalizer(int256 newDecimalsNormalizer)\n        external\n        override\n        onlyOwner\n    {\n        _setDecimalsNormalizer(newDecimalsNormalizer);\n    }\n\n    /// @notice sets the referenced backup oracle\n    /// @param newBackupOracle the new backup oracle to reference\n    function setBackupOracle(address newBackupOracle)\n        external\n        override\n        onlyOwner\n    {\n        _setBackupOracle(newBackupOracle);\n    }\n\n    /// @notice invert a peg price\n    /// @param price the peg price to invert\n    /// @return the inverted peg as a Decimal\n    /// @dev the inverted peg would be X per Token\n    function invert(Decimal.D256 memory price)\n        public\n        pure\n        override\n        returns (Decimal.D256 memory)\n    {\n        return Decimal.one().div(price);\n    }\n\n    /// @notice updates the referenced oracle\n    function updateOracle() public override {\n        oracle.update();\n    }\n\n    /// @notice the peg price of the referenced oracle\n    /// @return the peg as a Decimal\n    /// @dev the peg is defined as Pool token per X with X being ETH, dollars, etc\n    function readOracle() public view override returns (Decimal.D256 memory) {\n        (Decimal.D256 memory _peg, bool valid) = oracle.read();\n        if (!valid && address(backupOracle) != address(0)) {\n            (_peg, valid) = backupOracle.read();\n        }\n        require(valid, \"OracleRef: oracle invalid\");\n\n        // Scale the oracle price by token decimals delta if necessary\n        uint256 scalingFactor;\n        if (decimalsNormalizer < 0) {\n            scalingFactor = 10**(-1 * decimalsNormalizer).toUint256();\n            _peg = _peg.div(scalingFactor);\n        } else {\n            scalingFactor = 10**decimalsNormalizer.toUint256();\n            _peg = _peg.mul(scalingFactor);\n        }\n\n        // Invert the oracle price if necessary\n        if (doInvert) {\n            _peg = invert(_peg);\n        }\n        return _peg;\n    }\n\n    function _setOracle(address newOracle) internal {\n        require(newOracle != address(0), \"OracleRef: zero address\");\n        address oldOracle = address(oracle);\n        oracle = IOracle(newOracle);\n        emit OracleUpdate(oldOracle, newOracle);\n    }\n\n    // Supports zero address if no backup\n    function _setBackupOracle(address newBackupOracle) internal {\n        address oldBackupOracle = address(backupOracle);\n        backupOracle = IOracle(newBackupOracle);\n        emit BackupOracleUpdate(oldBackupOracle, newBackupOracle);\n    }\n\n    function _setDoInvert(bool newDoInvert) internal {\n        bool oldDoInvert = doInvert;\n        doInvert = newDoInvert;\n\n        if (oldDoInvert != newDoInvert) {\n            _setDecimalsNormalizer(-1 * decimalsNormalizer);\n        }\n\n        emit InvertUpdate(oldDoInvert, newDoInvert);\n    }\n\n    function _setDecimalsNormalizer(int256 newDecimalsNormalizer) internal {\n        int256 oldDecimalsNormalizer = decimalsNormalizer;\n        decimalsNormalizer = newDecimalsNormalizer;\n        emit DecimalsNormalizerUpdate(\n            oldDecimalsNormalizer,\n            newDecimalsNormalizer\n        );\n    }\n}\n"
    },
    "src/refs/IOracleRef.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity =0.8.13;\n\nimport \"../oracle/IOracle.sol\";\n\n/// @title OracleRef interface\ninterface IOracleRef {\n    // ----------- Events -----------\n\n    event OracleUpdate(address indexed oldOracle, address indexed newOracle);\n\n    event InvertUpdate(bool oldDoInvert, bool newDoInvert);\n\n    event DecimalsNormalizerUpdate(\n        int256 oldDecimalsNormalizer,\n        int256 newDecimalsNormalizer\n    );\n\n    event BackupOracleUpdate(\n        address indexed oldBackupOracle,\n        address indexed newBackupOracle\n    );\n\n    // ----------- State changing API -----------\n\n    function updateOracle() external;\n\n    function setOracle(address newOracle) external;\n\n    function setBackupOracle(address newBackupOracle) external;\n\n    function setDecimalsNormalizer(int256 newDecimalsNormalizer) external;\n\n    function setDoInvert(bool newDoInvert) external;\n\n    // ----------- Getters -----------\n\n    function oracle() external view returns (IOracle);\n\n    function backupOracle() external view returns (IOracle);\n\n    function doInvert() external view returns (bool);\n\n    function decimalsNormalizer() external view returns (int256);\n\n    function readOracle() external view returns (Decimal.D256 memory);\n\n    function invert(Decimal.D256 calldata price)\n        external\n        pure\n        returns (Decimal.D256 memory);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "src/oracle/IOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity =0.8.13;\n\nimport \"../external/Decimal.sol\";\n\n/// @title generic oracle interface\ninterface IOracle {\n    // ----------- Events -----------\n\n    event Update(uint256 _peg);\n\n    // ----------- State changing API -----------\n\n    function update() external;\n\n    // ----------- Getters -----------\n\n    function read() external view returns (Decimal.D256 memory, bool);\n\n    function isOutdated() external view returns (bool);\n}\n"
    },
    "src/external/Decimal.sol": {
      "content": "/*\n    Copyright 2019 dYdX Trading Inc.\n    Copyright 2020 Empty Set Squad <emptysetsquad@protonmail.com>\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @title Decimal\n * @author dYdX\n *\n * Library that defines a fixed-point number with 18 decimal places.\n */\nlibrary Decimal {\n    using SafeMath for uint256;\n\n    // ============ Constants ============\n\n    uint256 private constant BASE = 10**18;\n\n    // ============ Structs ============\n\n    struct D256 {\n        uint256 value;\n    }\n\n    // ============ Static Functions ============\n\n    function zero() internal pure returns (D256 memory) {\n        return D256({value: 0});\n    }\n\n    function one() internal pure returns (D256 memory) {\n        return D256({value: BASE});\n    }\n\n    function from(uint256 a) internal pure returns (D256 memory) {\n        return D256({value: a.mul(BASE)});\n    }\n\n    function ratio(uint256 a, uint256 b) internal pure returns (D256 memory) {\n        return D256({value: getPartial(a, BASE, b)});\n    }\n\n    // ============ Self Functions ============\n\n    function add(D256 memory self, uint256 b)\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({value: self.value.add(b.mul(BASE))});\n    }\n\n    function sub(D256 memory self, uint256 b)\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({value: self.value.sub(b.mul(BASE))});\n    }\n\n    function sub(\n        D256 memory self,\n        uint256 b,\n        string memory reason\n    ) internal pure returns (D256 memory) {\n        return D256({value: self.value.sub(b.mul(BASE), reason)});\n    }\n\n    function mul(D256 memory self, uint256 b)\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({value: self.value.mul(b)});\n    }\n\n    function div(D256 memory self, uint256 b)\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({value: self.value.div(b)});\n    }\n\n    function pow(D256 memory self, uint256 b)\n        internal\n        pure\n        returns (D256 memory)\n    {\n        if (b == 0) {\n            return from(1);\n        }\n\n        D256 memory temp = D256({value: self.value});\n        for (uint256 i = 1; i < b; i++) {\n            temp = mul(temp, self);\n        }\n\n        return temp;\n    }\n\n    function add(D256 memory self, D256 memory b)\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({value: self.value.add(b.value)});\n    }\n\n    function sub(D256 memory self, D256 memory b)\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({value: self.value.sub(b.value)});\n    }\n\n    function sub(\n        D256 memory self,\n        D256 memory b,\n        string memory reason\n    ) internal pure returns (D256 memory) {\n        return D256({value: self.value.sub(b.value, reason)});\n    }\n\n    function mul(D256 memory self, D256 memory b)\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({value: getPartial(self.value, b.value, BASE)});\n    }\n\n    function div(D256 memory self, D256 memory b)\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({value: getPartial(self.value, BASE, b.value)});\n    }\n\n    function equals(D256 memory self, D256 memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        return self.value == b.value;\n    }\n\n    function greaterThan(D256 memory self, D256 memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        return compareTo(self, b) == 2;\n    }\n\n    function lessThan(D256 memory self, D256 memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        return compareTo(self, b) == 0;\n    }\n\n    function greaterThanOrEqualTo(D256 memory self, D256 memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        return compareTo(self, b) > 0;\n    }\n\n    function lessThanOrEqualTo(D256 memory self, D256 memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        return compareTo(self, b) < 2;\n    }\n\n    function isZero(D256 memory self) internal pure returns (bool) {\n        return self.value == 0;\n    }\n\n    function asUint256(D256 memory self) internal pure returns (uint256) {\n        return self.value.div(BASE);\n    }\n\n    // ============ Core Methods ============\n\n    function getPartial(\n        uint256 target,\n        uint256 numerator,\n        uint256 denominator\n    ) private pure returns (uint256) {\n        return target.mul(numerator).div(denominator);\n    }\n\n    function compareTo(D256 memory a, D256 memory b)\n        private\n        pure\n        returns (uint256)\n    {\n        if (a.value == b.value) {\n            return 1;\n        }\n        return a.value > b.value ? 2 : 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "src/interfaces/IUniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.13;\n\ninterface IUniswapV2Router {\n    function WETH() external pure returns (address);\n\n    function factory() external pure returns (address);\n\n    function getAmountsOut(uint256 amountIn, address[] memory path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n}\n"
    },
    "src/external/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.13;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport {IUniswapV2Pair} from \"../interfaces/IUniswapV2Pair.sol\";\nimport {IUniswapV2Factory} from \"../interfaces/IUniswapV2Factory.sol\";\n\nlibrary UniswapV2Library {\n    using SafeMath for uint256;\n\n    function sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n    }\n\n    function getReserves(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        // (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        // (uint reserve0, uint reserve1,) = IUniswapV2Pair(address(IUniswapV2Factory(factory).getPair(tokenA, tokenB))).getReserves();\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(\n            address(IUniswapV2Factory(factory).getPair(tokenB, tokenA))\n        ).getReserves();\n        (reserveA, reserveB) = tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address factory,\n        uint256 amountIn,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                factory,\n                path[i],\n                path[i + 1]\n            );\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "src/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.13;\n\ninterface IUniswapV2Pair {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to)\n        external\n        returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "src/interfaces/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.13;\n\ninterface IUniswapV2Factory {\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint256\n    );\n\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair);\n}\n"
    },
    "src/oracle/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.13;\n\nimport {OracleRef} from \"../refs/OracleRef.sol\";\n\ncontract PriceOracle is OracleRef {\n    constructor(\n        address _oracle,\n        address _backupOracle,\n        bool _isInvert\n    ) OracleRef(_oracle, _backupOracle, 0, _isInvert) {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "src/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20, ERC20Burnable {\n    constructor(string memory tokenName) ERC20(tokenName, \"MCT\") {}\n\n    function mint(address account, uint256 amount) public returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n}\n"
    },
    "src/mocks/MockWeth.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"./MockERC20.sol\";\n\ncontract MockWeth is MockERC20 {\n    constructor(\n        string memory tokenName\n    ) MockERC20(tokenName) {}\n\n    function deposit() external payable {\n    \tmint(msg.sender, msg.value);\n    }\n\n    function withdraw(uint amount) external payable {\n    \t_burn(msg.sender, amount);\n    \tpayable(msg.sender).transfer(amount);\n    }\n}\n"
    },
    "src/oracle/ChainlinkOracleWrapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity =0.8.13;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IOracle, Decimal} from \"./IOracle.sol\";\n\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n/// @title Chainlink oracle wrapper\n/// @notice Reads a Chainlink oracle value & wrap it under the standard oracle interface\ncontract ChainlinkOracleWrapper is IOracle, Pausable {\n    using Decimal for Decimal.D256;\n\n    /// @notice the referenced chainlink oracle\n    AggregatorV3Interface public chainlinkOracle;\n    uint256 public oracleDecimalsNormalizer;\n\n    /// @notice ChainlinkOracleWrapper constructor\n    /// @param _chainlinkOracle reference to the target Chainlink oracle\n    constructor(address _chainlinkOracle) {\n        chainlinkOracle = AggregatorV3Interface(_chainlinkOracle);\n\n        _init();\n    }\n\n    // @dev: decimals of the oracle are expected to never change, if Chainlink\n    // updates that behavior in the future, we might consider reading the\n    // oracle decimals() on every read() call.\n    function _init() internal {\n        uint8 oracleDecimals = chainlinkOracle.decimals();\n        oracleDecimalsNormalizer = 10**uint256(oracleDecimals);\n    }\n\n    /// @notice updates the oracle price\n    /// @dev no-op, Chainlink is updated automatically\n    function update() external view override whenNotPaused {}\n\n    /// @notice determine if read value is stale\n    /// @return true if read value is stale\n    function isOutdated() external view override returns (bool) {\n        (uint80 roundId, , , , uint80 answeredInRound) = chainlinkOracle\n            .latestRoundData();\n        return answeredInRound != roundId;\n    }\n\n    /// @notice read the oracle price\n    /// @return oracle price\n    /// @return true if price is valid\n    function read() external view override returns (Decimal.D256 memory, bool) {\n        (\n            uint80 roundId,\n            int256 price,\n            ,\n            ,\n            uint80 answeredInRound\n        ) = chainlinkOracle.latestRoundData();\n        bool valid = !paused() && price > 0 && answeredInRound == roundId;\n\n        Decimal.D256 memory value = Decimal.from(uint256(price)).div(\n            oracleDecimalsNormalizer\n        );\n        return (value, valid);\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "src/mocks/MockChainlinkOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity =0.8.13;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ncontract MockChainlinkOracle is AggregatorV3Interface {\n    // fixed value\n    int256 public _value;\n    uint8 public _decimals;\n\n    // mocked data\n    uint80 _roundId;\n    uint256 _startedAt;\n    uint256 _updatedAt;\n    uint80 _answeredInRound;\n\n    constructor(int256 value, uint8 decimals) {\n        _value = value;\n        _decimals = decimals;\n        _roundId = 42;\n        _startedAt = 1620651856;\n        _updatedAt = 1620651856;\n        _answeredInRound = 42;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return _decimals;\n    }\n\n    function description() external pure override returns (string memory) {\n        return \"MockChainlinkOracle\";\n    }\n\n    function getRoundData(uint80 _getRoundId)\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        return (_getRoundId, _value, 1620651856, 1620651856, _getRoundId);\n    }\n\n    function latestRoundData()\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        return (_roundId, _value, _startedAt, _updatedAt, _answeredInRound);\n    }\n\n    function set(\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    ) external {\n        _roundId = roundId;\n        _value = answer;\n        _startedAt = startedAt;\n        _updatedAt = updatedAt;\n        _answeredInRound = answeredInRound;\n    }\n\n    function version() external pure override returns (uint256) {\n        return 1;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}